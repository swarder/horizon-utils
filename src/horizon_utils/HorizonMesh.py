import numpy as np
import scipy
import trimesh
import segyio
from sklearn.linear_model import LinearRegression
from scipy.spatial import Delaunay
from scipy.interpolate import griddata
import pandas as pd

class HorizonMesh:
    def __init__(self, vertices, faces, crs):
        self.vertices = vertices
        self.faces = faces
        self.crs = crs

    def convert_to_utm(self, segy_file):
        """Transform mesh vertices to UTM coordinates using a SEGY file."""
        if self.crs == 'utm':
            print("Mesh is already in UTM coordinates.")
            return
        else:
            transformer = self.generate_ix_to_utm_transformer(segy_file)
            self.vertices[:,:2] = transformer(self.vertices[:,:2])
            self.crs = 'utm'
    
    def convert_from_utm(self, segy_file):
        """Transform mesh vertices from UTM coordinates using a SEGY file."""
        if self.crs == 'inline_crossline':
            print("Mesh is already in inline/crossline coordinates.")
            return
        elif self.crs == 'utm':
            transformer = self.generate_utm_to_ix_transformer(segy_file)
            self.vertices[:,:2] = transformer(self.vertices[:,:2])
            self.crs = 'inline_crossline'
    
    @classmethod
    def from_ts(cls, ts_path):
        """Load mesh from a TS file (e.g. generated by Petrel)

        Args:
            ts_path: Path to the TS file.

        Returns:
            HorizonMesh: An instance of HorizonMesh containing vertices and faces.
        """
        vertices = []
        faces = []

        with open(ts_path, 'r') as f:
            for line in f:
                parts = line.strip().split()
                if not parts:
                    continue
                if parts[0] in ('VRTX', 'PVRTX'):
                    vertices.append([float(parts[2]), float(parts[3]), float(parts[4])])
                elif parts[0] == 'TRGL':
                    faces.append([int(parts[1]), int(parts[2]), int(parts[3])])

        return cls(np.array(vertices), np.array(faces), crs='utm')

    @classmethod
    def from_text_file(cls, file_path, crs, **kwargs):
        """Load mesh from a text file.

        Args:
            file_path: Path to the text file containing vertices.
            **kwargs: Additional arguments for loading vertices.

        Returns:
            HorizonMesh: An instance of HorizonMesh.
        """
        vertices = pd.read_csv(file_path, **kwargs).values
        return cls.from_vertices(vertices, crs)
    
    @classmethod
    def from_DUG_ilclt(cls, filename):
        """Load mesh from a DUG ilclt file.

        Args:
            filename: Path to the DUG ilclt file.

        Returns:
            HorizonMesh: An instance of HorizonMesh.
        """
        return cls.from_text_file(filename, crs='inline_crossline', sep=r'\s+', comment='#')
    
    @classmethod
    def from_dugmsh(cls, filename):
        """Load mesh from a .dugmsh file.

        Args:
            filename: Path to the dugmsh file.

        Returns:
            HorizonMesh: An instance of HorizonMesh.
        """
        return cls.from_text_file(filename, crs='inline_crossline', sep=r'\s+', skiprows=14)
    
    @classmethod
    def from_DUG_dat(cls, filename):
        """Load mesh from a DUG dat file.

        Args:
            filename: Path to the DUG dat file.

        Returns:
            HorizonMesh: An instance of HorizonMesh.
        """
        return cls.from_text_file(filename, crs='inline_crossline', sep=r'\s+', usecols=[0, 1, 4])
    
    @classmethod
    def from_vertices(cls, vertices, crs):
        """Create a HorizonMesh instance from vertices.

        Args:
            vertices: A numpy array of shape (n, 3) representing the mesh vertices.
            crs: The coordinate reference system of the vertices.

        Returns:
            HorizonMesh: An instance of HorizonMesh.
        """
        tri = Delaunay(vertices[:,:2])
        faces = tri.simplices
        return cls(vertices, faces, crs=crs)

    @classmethod
    def generate_utm_to_ix_transformer(cls, segy_file):
        """Generate transformer from UTM to I/X.

        Args:
            segy_file: The SEGY file containing the necessary transformation information.
        """
        # Load the SEGY file and extract the necessary transformation information
        with segyio.open(segy_file, "r", ignore_geometry=True) as f:
            inlines = f.attributes(segyio.TraceField.INLINE_3D)[:]
            crosslines = f.attributes(segyio.TraceField.CROSSLINE_3D)[:]
            xs = f.attributes(segyio.TraceField.CDP_X)[:]/100
            ys = f.attributes(segyio.TraceField.CDP_Y)[:]/100

        grid = np.column_stack([xs, ys])
        reg_east = LinearRegression().fit(grid, inlines)
        reg_north = LinearRegression().fit(grid, crosslines)

        def transform(vertices_utm):
            """Transform (easting, northing) to (inline, crossline)."""
            i_pred = reg_east.predict(vertices_utm)
            x_pred = reg_north.predict(vertices_utm)
            return np.stack([i_pred, x_pred], axis=-1)

        return transform
    
    @classmethod
    def generate_ix_to_utm_transformer(cls, segy_file):
        """Generate transformer from I/X to UTM.

        Args:
            segy_file: The SEGY file containing the necessary transformation information.
        """
        with segyio.open(segy_file, "r", ignore_geometry=True) as f:
            inlines = f.attributes(segyio.TraceField.INLINE_3D)[:]
            crosslines = f.attributes(segyio.TraceField.CROSSLINE_3D)[:]
            xs = f.attributes(segyio.TraceField.CDP_X)[:]/100
            ys = f.attributes(segyio.TraceField.CDP_Y)[:]/100

        grid = np.column_stack([inlines, crosslines])
        reg_east = LinearRegression().fit(grid, xs)
        reg_north = LinearRegression().fit(grid, ys)

        def transform(vertices_ix):
            """Transform (inline, crossline) to (easting, northing)."""
            e_pred = reg_east.predict(vertices_ix)
            n_pred = reg_north.predict(vertices_ix)
            return np.stack([e_pred, n_pred], axis=-1)

        return transform
    
    def to_file(self, filename, format, **kwargs):
        """Save the HorizonMesh to file"""
        if format == 'trimesh':
            m = trimesh.Trimesh(vertices=self.vertices, faces=self.faces, process=False)
            m.export(filename)
        elif format == 'text':
            with open(filename, 'w') as f:
                sep = kwargs.get('sep', '\t')
                vertices_df = pd.DataFrame(self.vertices, columns=['x', 'y', 'z']).dropna()
                vertices_df.to_csv(f, sep=sep, index=False, header=False)
        else:
            raise NotImplementedError

    def regrid(self, resolution):
        """Regrid the mesh to a new resolution.

        Args:
            resolution: The new resolution for the mesh.
        """
        new_x = np.arange(int(self.vertices[:, 0].min())+1, self.vertices[:, 0].max(), resolution)
        new_y = np.arange(int(self.vertices[:, 1].min())+1, self.vertices[:, 1].max(), resolution)
        new_x, new_y = np.meshgrid(new_x, new_y)

        # Regrid
        new_z = griddata((self.vertices[:,0], self.vertices[:,1]), self.vertices[:, 2],
                          (new_x, new_y), method='linear')
        new_vertices = np.column_stack([new_x.flatten(), new_y.flatten(), new_z.flatten()])
        new_faces = Delaunay(new_vertices[:, :2]).simplices
        self.vertices = new_vertices
        self.faces = new_faces
        return self
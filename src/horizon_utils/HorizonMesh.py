import numpy as np
import trimesh
import segyio
from sklearn.linear_model import LinearRegression
from scipy.spatial import Delaunay

class HorizonMesh:
    def __init__(self, vertices, faces, crs):
        self.vertices = vertices
        self.faces = faces
        self.crs = crs

    def convert_to_utm(self, segy_file):
        """Transform mesh vertices to UTM coordinates using a SEGY file."""
        if self.crs == 'utm':
            print("Mesh is already in UTM coordinates.")
            return
        else:
            transformer = self.generate_ix_to_utm_transformer(segy_file)
            self.vertices[:,:2] = transformer(self.vertices[:,:2])
            self.crs = 'utm'
    
    def convert_from_utm(self, segy_file):
        """Transform mesh vertices from UTM coordinates using a SEGY file."""
        if self.crs == 'inline_crossline':
            print("Mesh is already in inline/crossline coordinates.")
            return
        elif self.crs == 'utm':
            transformer = self.generate_utm_to_ix_transformer(segy_file)
            self.vertices[:,:2] = transformer(self.vertices[:,:2])
            self.crs = 'inline_crossline'
    
    @classmethod
    def from_ts(cls, ts_path):
        """Load mesh from a TS file (e.g. generated by Petrel)

        Args:
            ts_path: Path to the TS file.

        Returns:
            HorizonMesh: An instance of HorizonMesh containing vertices and faces.
        """
        vertices = []
        faces = []

        with open(ts_path, 'r') as f:
            for line in f:
                parts = line.strip().split()
                if not parts:
                    continue
                if parts[0] in ('VRTX', 'PVRTX'):
                    vertices.append([float(parts[2]), float(parts[3]), float(parts[4])])
                elif parts[0] == 'TRGL':
                    faces.append([int(parts[1]), int(parts[2]), int(parts[3])])

        return cls(np.array(vertices), np.array(faces), crs='utm')
    
    @classmethod
    def from_vertices(cls, vertices, crs):
        """Create a HorizonMesh instance from vertices.

        Args:
            vertices: A numpy array of shape (n, 3) representing the mesh vertices.
            crs: The coordinate reference system of the vertices.

        Returns:
            HorizonMesh: An instance of HorizonMesh.
        """
        tri = Delaunay(vertices[:,:2])
        faces = tri.simplices
        return cls(vertices, faces, crs=crs)

    @classmethod
    def generate_utm_to_ix_transformer(cls, segy_file):
        """Generate transformer from UTM to I/X.

        Args:
            segy_file: The SEGY file containing the necessary transformation information.
        """
        # Load the SEGY file and extract the necessary transformation information
        with segyio.open(segy_file, "r", ignore_geometry=True) as f:
            inlines = f.attributes(segyio.TraceField.INLINE_3D)[:]
            crosslines = f.attributes(segyio.TraceField.CROSSLINE_3D)[:]
            xs = f.attributes(segyio.TraceField.CDP_X)[:]/100
            ys = f.attributes(segyio.TraceField.CDP_Y)[:]/100

        grid = np.column_stack([xs, ys])
        reg_east = LinearRegression().fit(grid, inlines)
        reg_north = LinearRegression().fit(grid, crosslines)

        def transform(vertices_utm):
            """Transform (easting, northing) to (inline, crossline)."""
            i_pred = reg_east.predict(vertices_utm)
            x_pred = reg_north.predict(vertices_utm)
            return np.stack([i_pred, x_pred], axis=-1)

        return transform
    
    @classmethod
    def generate_ix_to_utm_transformer(cls, segy_file):
        """Generate transformer from I/X to UTM.

        Args:
            segy_file: The SEGY file containing the necessary transformation information.
        """
        with segyio.open(segy_file, "r", ignore_geometry=True) as f:
            inlines = f.attributes(segyio.TraceField.INLINE_3D)[:]
            crosslines = f.attributes(segyio.TraceField.CROSSLINE_3D)[:]
            xs = f.attributes(segyio.TraceField.CDP_X)[:]/100
            ys = f.attributes(segyio.TraceField.CDP_Y)[:]/100

        grid = np.column_stack([inlines, crosslines])
        reg_east = LinearRegression().fit(grid, xs)
        reg_north = LinearRegression().fit(grid, ys)

        def transform(vertices_ix):
            """Transform (inline, crossline) to (easting, northing)."""
            e_pred = reg_east.predict(vertices_ix)
            n_pred = reg_north.predict(vertices_ix)
            return np.stack([e_pred, n_pred], axis=-1)

        return transform
    
    def save(self, filename):
        """Save the HorizonMesh to file"""
        m = trimesh.Trimesh(vertices=self.vertices, faces=self.faces, process=False)
        m.export(filename)
